// ─────────────────────────────────────────────────────────────────────────────
// Phantom Pool Relayer — Prover
// ─────────────────────────────────────────────────────────────────────────────
// Generates a MatchCorrectnessProof for a matched pair using the Barretenberg
// (bb) CLI and optionally converts it to Garaga calldata.
//
// Proof flow:
//   1. Write Prover.toml with the matched order's private + public inputs
//   2. nargo execute  → generates target/witness.gz
//   3. bb prove -s ultra_honk --oracle_hash keccak → generates proof + public_inputs
//   4. (optional) garaga calldata generation via Python script
//
//

import { $ } from "bun";
import { resolve, join } from "path";
import { mkdtemp, writeFile, readFile, rm } from "fs/promises";
import { tmpdir } from "os";
import { config } from "./config.js";
import type { Order, MatchResult } from "./types.js";

// ─── Prover.toml writer ───────────────────────────────────────────────────────
function buildProverToml(
  buy: Order,
  sell: Order,
  match: MatchResult
): string {
  // All field values must be decimal or 0x-hex strings as per Noir's Prover.toml spec.
  // Nonces are Field elements so we keep them as hex.
  return `# Auto-generated by Phantom Pool relayer for match ${match.matchId}
buy_price = "${buy.price.toString()}"
buy_amount = "${buy.amount.toString()}"
buy_nonce = "0x${buy.nonce.toString(16)}"
sell_price = "${sell.price.toString()}"
sell_amount = "${sell.amount.toString()}"
sell_nonce = "0x${sell.nonce.toString(16)}"
settlement_amount = "${match.settlementAmount.toString()}"
settlement_price = "${match.settlementPrice.toString()}"

buy_commitment = "${buy.commitment}"
sell_commitment = "${sell.commitment}"
settlement_commitment = "${match.settlementCommitment}"
`;
}



// ─── Main prove function ──────────────────────────────────────────────────────
export async function prove(
  buy: Order,
  sell: Order,
  match: MatchResult
): Promise<{ calldata: string[]; proofBytes?: Buffer; publicInputsBytes?: Buffer }> {


  // ── 1. Create a temp working directory so parallel proving doesn't conflict ──
  const workDir = await mkdtemp(join(tmpdir(), "phantom-proof-"));
  console.log(`[prover] Working dir: ${workDir}`);

  try {
    const circuitDir = config.circuitDir;

    // ── 2. Copy circuit sources into workDir ─────────────────────────────────
    // We cd into the original circuit dir and use bb/nargo from there,
    // writing outputs to workDir.
    const proverToml = buildProverToml(buy, sell, match);
    const proverTomlPath = join(circuitDir, "Prover.toml");
    await writeFile(proverTomlPath, proverToml, "utf8");
    console.log(`[prover] Wrote Prover.toml for match ${match.matchId}`);

    // ── 3. nargo execute ─────────────────────────────────────────────────────
    console.log(`[prover] Running nargo execute…`);
    const nargoResult = await $`${config.nargoBin} execute`
      .cwd(circuitDir)
      .quiet();
    if (nargoResult.exitCode !== 0) {
      throw new Error(`nargo execute failed: ${nargoResult.stderr.toString()}`);
    }
    console.log(`[prover] nargo execute OK`);

    // ── 4. Locate compiled circuit and vk ────────────────────────────────────
    const circuitJson = join(circuitDir, "target", "match_correctness.json");
    const witnessGz  = join(circuitDir, "target", "match_correctness.gz");
    const vkPath     = join(circuitDir, "target", "vk");
    const proofDir   = join(workDir, "proof");

    // ── 5. Write vk if not already present ───────────────────────────────────
    try {
      await readFile(join(vkPath, "vk"));
      console.log(`[prover] VK already exists, skipping write_vk`);
    } catch {
      console.log(`[prover] Generating VK…`);
      const vkResult = await $`${config.bbBin} write_vk \
        -s ultra_honk --oracle_hash keccak \
        -b ${circuitJson} \
        -o ${vkPath}`
        .quiet();
      if (vkResult.exitCode !== 0) {
        throw new Error(`bb write_vk failed: ${vkResult.stderr.toString()}`);
      }
      console.log(`[prover] VK generated`);
    }

    // ── 6. bb prove ──────────────────────────────────────────────────────────
    console.log(`[prover] Running bb prove…`);
    const bbResult = await $`${config.bbBin} prove \
      -s ultra_honk --oracle_hash keccak \
      -b ${circuitJson} \
      -w ${witnessGz} \
      -k ${join(vkPath, "vk")} \
      -o ${proofDir}`
      .quiet();
    if (bbResult.exitCode !== 0) {
      throw new Error(`bb prove failed: ${bbResult.stderr.toString()}`);
    }
    console.log(`[prover] Proof generated`);

    // ── 7. Read proof and public_inputs ─────────────────────────────────────
    const proofBytes = await readFile(join(proofDir, "proof"));
    const pubInputsBytes = await readFile(join(proofDir, "public_inputs"));
    console.log(`[prover] Proof size: ${proofBytes.length} bytes`);

    // ── 8. Generate Garaga calldata (Python) ──────────────────────────────────
    console.log(`[prover] Generating Garaga calldata…`);
    const calldataJsonPath = join(workDir, "calldata.json");

    const garagaScript = `
import sys, json
from garaga.precompiled_circuits.zk_honk import HonkVk, ZKHonkProof
from garaga.starknet.honk_contract_generator.calldata import (
    get_ultra_flavor_honk_calldata_from_vk_and_proof
)
vk = HonkVk.from_bytes(open('${join(vkPath, "vk")}', 'rb').read())
proof_bytes = open('${join(proofDir, "proof")}', 'rb').read()
pub_bytes   = open('${join(proofDir, "public_inputs")}', 'rb').read()
proof = ZKHonkProof.from_bytes(proof_bytes, pub_bytes, vk)
calldata = get_ultra_flavor_honk_calldata_from_vk_and_proof(vk=vk, proof=proof)
with open('${calldataJsonPath}', 'w') as f:
    json.dump([hex(x) for x in calldata], f)
print("OK")
`;
    const scriptPath = join(workDir, "gen_calldata.py");
    await writeFile(scriptPath, garagaScript, "utf8");

    const pyResult = await $`python3 ${scriptPath}`.quiet();
    if (pyResult.exitCode !== 0) {
      throw new Error(
        `Garaga calldata generation failed: ${pyResult.stderr.toString()}`
      );
    }

    const calldataJson = await readFile(calldataJsonPath, "utf8");
    const calldata: string[] = JSON.parse(calldataJson);
    console.log(`[prover] Garaga calldata: ${calldata.length} felt252 elements`);

    return { calldata, proofBytes, publicInputsBytes: pubInputsBytes };

  } finally {
    // Clean up temp dir
    await rm(workDir, { recursive: true, force: true }).catch(() => {});
  }
}
